MODULE FIELD_MODULE

IMPLICIT NONE

TYPE FIELD_1RB
  REAL, POINTER :: P (:)
END TYPE

TYPE FIELD_2RB
  REAL, POINTER :: P (:,:)
END TYPE

TYPE FIELD_3RB
  REAL, POINTER :: P (:,:,:)
END TYPE

TYPE FIELD_1RB_VIEW
  REAL, POINTER :: V (:)
END TYPE

TYPE FIELD_2RB_VIEW
  REAL, POINTER :: V (:,:)
END TYPE

INTERFACE LG
  MODULE PROCEDURE ::        LG2RB, LG3RB
END INTERFACE

INTERFACE LS
  MODULE PROCEDURE :: LS1RB, LS2RB, LS3RB
END INTERFACE

INTERFACE FIELD_NEW
  MODULE PROCEDURE :: FIELD_NEW_1RB, FIELD_NEW_2RB, FIELD_NEW_3RB
END INTERFACE

CONTAINS

SUBROUTINE FIELD_NEW_1RB (YLF, UBOUNDS)

CLASS (FIELD_1RB), POINTER :: YLF
INTEGER :: UBOUNDS (1)

ALLOCATE (YLF)
ALLOCATE (YLF%P (UBOUNDS (1)))

END SUBROUTINE

SUBROUTINE FIELD_NEW_2RB (YLF, UBOUNDS)

CLASS (FIELD_2RB), POINTER :: YLF
INTEGER :: UBOUNDS (2)

ALLOCATE (YLF)
ALLOCATE (YLF%P (UBOUNDS (1), UBOUNDS (2)))

END SUBROUTINE

SUBROUTINE FIELD_NEW_3RB (YLF, UBOUNDS)

CLASS (FIELD_3RB), POINTER :: YLF
INTEGER :: UBOUNDS (3)

ALLOCATE (YLF)
ALLOCATE (YLF%P (UBOUNDS (1), UBOUNDS (2), UBOUNDS (3)))

END SUBROUTINE

FUNCTION LG2RB (YLF)

CLASS (FIELD_2RB), POINTER :: YLF

TYPE (FIELD_2RB_VIEW), ALLOCATABLE :: LG2RB (:)

REAL, POINTER :: ZZ2 (:,:)
INTEGER :: I2, I3, J

ZZ2 => YLF%P

ALLOCATE (LG2RB (1))

LG2RB (1)%V => ZZ2

END FUNCTION

FUNCTION LG3RB (YLF)

CLASS (FIELD_3RB), POINTER :: YLF

TYPE (FIELD_2RB_VIEW), ALLOCATABLE :: LG3RB (:)

REAL, POINTER :: ZZ3 (:,:,:)
INTEGER :: I2, J

ZZ3 => YLF%P

ALLOCATE (LG3RB (SIZE (ZZ3, 2)))

J = 1

DO I2 = LBOUND (ZZ3, 2), UBOUND (ZZ3, 2)
  LG3RB (J)%V => ZZ3 (:, I2, :)
  J = J + 1
ENDDO

END FUNCTION

FUNCTION LS1RB (YLF)

CLASS (FIELD_1RB), POINTER :: YLF

TYPE (FIELD_1RB_VIEW), ALLOCATABLE :: LS1RB (:)

REAL, POINTER :: ZZ1 (:)

ZZ1 => YLF%P

ALLOCATE (LS1RB (1))

LS1RB (1)%V => ZZ1 

END FUNCTION

FUNCTION LS2RB (YLF)

CLASS (FIELD_2RB), POINTER :: YLF

TYPE (FIELD_1RB_VIEW), ALLOCATABLE :: LS2RB (:)

REAL, POINTER :: ZZ2 (:,:)
INTEGER :: I2, I3, J

ZZ2 => YLF%P

ALLOCATE (LS2RB (SIZE (ZZ2, 2)))

J = 1

DO I2 = LBOUND (ZZ2, 2), UBOUND (ZZ2, 2)
  LS2RB (J)%V => ZZ2 (:, I2)
  J = J + 1
ENDDO

END FUNCTION

FUNCTION LS3RB (YLF)

CLASS (FIELD_3RB), POINTER :: YLF

TYPE (FIELD_1RB_VIEW), ALLOCATABLE :: LS3RB (:)

REAL, POINTER :: ZZ3 (:,:,:)
INTEGER :: I2, I3, J

ZZ3 => YLF%P

ALLOCATE (LS3RB (SIZE (ZZ3, 2) * SIZE (ZZ3, 3)))

J = 1

DO I3 = LBOUND (ZZ3, 3), UBOUND (ZZ3, 3)
  DO I2 = LBOUND (ZZ3, 2), UBOUND (ZZ3, 2)
    LS3RB (J)%V => ZZ3 (:, I2, I3)
    J = J + 1
  ENDDO
ENDDO

END FUNCTION

END MODULE

MODULE INV_TRANS_MODULE

USE FIELD_MODULE

CONTAINS

SUBROUTINE INV_TRANS (U, V, VOR, DIV, VSETUV, GRID, SPEC, VSET)

TYPE (FIELD_2RB_VIEW), OPTIONAL :: U (:), V (:), GRID (:)
TYPE (FIELD_1RB_VIEW), OPTIONAL :: VOR (:), DIV (:), SPEC (:)
INTEGER, OPTIONAL :: VSETUV (:), VSET (:)

REAL, ALLOCATABLE :: ZGPUV (:,:,:,:), ZSPVOR (:,:), ZSPDIV (:,:), ZGP (:,:,:), ZSPSCALAR (:,:)
INTEGER :: IPROMA, IGPBLKS, IFLDGUV, ISPEC2, IFLDSUV

IF (PRESENT (U) .NEQV. PRESENT (V)) STOP "U/V"
IF (PRESENT (U) .NEQV. PRESENT (VOR)) STOP "U/VOR"
IF (PRESENT (U) .NEQV. PRESENT (DIV)) STOP "U/DIV"
IF (PRESENT (U) .NEQV. PRESENT (VSETUV)) STOP "U/VSETUV"

IF (PRESENT (U)) THEN

  IF ((SIZE (U) /= SIZE (V)) .OR. (SIZE (VOR) /= SIZE (DIV)) .OR. (SIZE (VSETUV) /= SIZE (U))) THEN
    PRINT *, " U = ", SIZE (U)
    PRINT *, " V = ", SIZE (V)
    PRINT *, " VOR = ", SIZE (VOR)
    PRINT *, " DIV = ", SIZE (DIV)
    PRINT *, " VSETUV = ", SIZE (VSETUV)
    STOP 1
  ENDIF

  IPROMA = SIZE (U (1)%V, 1)
  IGPBLKS = SIZE (U (1)%V, 2) 
  IFLDGUV = SIZE (U)

  ISPEC2 = SIZE (VOR (1)%V, 1)
  IFLDSUV = SIZE (VOR)

  ALLOCATE (ZGPUV (IPROMA, IFLDGUV, 2, IGPBLKS), ZSPVOR (ISPEC2, IFLDSUV), ZSPDIV (ISPEC2, IFLDSUV))

  DO JFLD = 1, IFLDSUV
    ZSPVOR (:, JFLD) = VOR (JFLD)%V (:)
    ZSPDIV (:, JFLD) = DIV (JFLD)%V (:)
  ENDDO

ELSE

  IFLDSUV = 0
  ALLOCATE (ZGPUV (0, IFLDSUV, 2, 0), ZSPVOR (0, 0), ZSPDIV (0, 0))

ENDIF

IF (PRESENT (GRID) .NEQV. PRESENT (SPEC)) STOP "GRID/SPEC"
IF (PRESENT (GRID) .NEQV. PRESENT (VSET)) STOP "GRID/VSET"

IF (PRESENT (GRID)) THEN

  IF ((SIZE (GRID) /= SIZE (SPEC)) .AND. (SIZE (GRID) /= SIZE (VSET))) THEN
    PRINT *, " SIZE (GRID) = ", SIZE (GRID)
    PRINT *, " SIZE (SPEC) = ", SIZE (SPEC)
    PRINT *, " SIZE (VSET) = ", SIZE (VSET)
    STOP 1
  ENDIF

  IPROMA = SIZE (GRID (1)%V, 1)
  IGPBLKS = SIZE (GRID (1)%V, 2)
  IFLDG = SIZE (GRID)

  ISPEC2 = SIZE (SPEC (1)%V, 1)
  IFLDS = SIZE (SPEC)

  ALLOCATE (ZGP (IPROMA, IFLDG, IGPBLKS), ZSPSCALAR (ISPEC2, IFLDS))

  DO JFLD = 1, IFLDS
    ZSPSCALAR (:,JFLD) = SPEC (JFLD)%V (:)
  ENDDO

ELSE

  IFLDG = 0
  ALLOCATE (ZGP (0, IFLDG, 0), ZSPSCALAR (0, 0))

ENDIF

#ifdef UNDEF
CALL INV_TRANS (PSPVOR=ZSPVOR, PSPDIV=ZSPVIV, PGPUV=ZGPUV, KVSETUV=VSETUV, &
              & PSPSCALAR=ZSPSCALAR, PGP=ZGP, KVSETSC=VSET, KPROMA=IPROMA)
#endif

DO JFLD = 1, IFLDGUV
  U (JFLD)%V (:,:) = ZGPUV (:,JFLD,1,:)
  V (JFLD)%V (:,:) = ZGPUV (:,JFLD,2,:)
ENDDO

DO JFLD = 1, IFLDG
  GRID (JFLD)%V (:,:) = ZGP (:, JFLD, :)
ENDDO

END SUBROUTINE

END MODULE

PROGRAM MAIN

USE FIELD_MODULE
USE INV_TRANS_MODULE

INTEGER, PARAMETER :: NPRTRW = 5, NPRTRV = 3, MYSETW = 1, MYSETV = 1

INTEGER, PARAMETER :: NPROMA = 100, NFLEVG = 15, NGPBLKS = 10, NSPEC2 = 600
INTEGER :: NFLEVL 

CLASS (FIELD_3RB), POINTER :: GU, GV, GT, GQ
CLASS (FIELD_2RB), POINTER :: SVOR, SDIV, ST, SQ

CLASS (FIELD_2RB), POINTER :: GU1, GV1, GT1, GQ1
CLASS (FIELD_1RB), POINTER :: SVOR1, SDIV1, ST1, SQ1

TYPE (FIELD_2RB_VIEW), ALLOCATABLE :: U (:), V (:), GRID (:)
TYPE (FIELD_1RB_VIEW), ALLOCATABLE :: VOR (:), DIV (:), SPEC (:)

INTEGER :: NBSETP
INTEGER, ALLOCATABLE :: NBSETLEV (:)
INTEGER, ALLOCATABLE :: VSETUV (:)

INTEGER :: JLEV

NBSETSP = 1

ALLOCATE (NBSETLEV (NFLEVG))

DO JLEV = 1, NFLEVG
  NBSETLEV (JLEV) = 1 + ((JLEV-1) * (NPRTRV)) / NFLEVG
ENDDO

NFLEVL = COUNT (NBSETLEV == MYSETV)

CALL FIELD_NEW (GU, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])
CALL FIELD_NEW (GV, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])
CALL FIELD_NEW (GT, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])
CALL FIELD_NEW (GQ, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])

CALL FIELD_NEW (SVOR, UBOUNDS=[NSPEC2, NFLEVL])
CALL FIELD_NEW (SDIV, UBOUNDS=[NSPEC2, NFLEVL])
CALL FIELD_NEW (ST, UBOUNDS=[NSPEC2, NFLEVL])
CALL FIELD_NEW (SQ, UBOUNDS=[NSPEC2, NFLEVL])

CALL FIELD_NEW (GU1, UBOUNDS=[NPROMA, NGPBLKS])
CALL FIELD_NEW (GV1, UBOUNDS=[NPROMA, NGPBLKS])
CALL FIELD_NEW (GT1, UBOUNDS=[NPROMA, NGPBLKS])
CALL FIELD_NEW (GQ1, UBOUNDS=[NPROMA, NGPBLKS])

CALL FIELD_NEW (SVOR1, UBOUNDS=[NSPEC2])
CALL FIELD_NEW (SDIV1, UBOUNDS=[NSPEC2])
CALL FIELD_NEW (ST1, UBOUNDS=[NSPEC2, NFLEVL])
CALL FIELD_NEW (SQ1, UBOUNDS=[NSPEC2, NFLEVL])

! Create list arguments

CALL INV_TRANS (U=[LG (GU), LG (GU1)], VOR=[LS (SVOR), LS (SVOR1)], &
              & V=[LG (GV), LG (GV1)], DIV=[LS (SDIV), LS (SDIV1)], &
              & VSETUV=[NBSETLEV, NBSETSP], &
              & GRID=[LG (GT), LG (GQ), LG (GT1), LG (GQ1)], &
              & SPEC=[LS (ST), LS (SQ), LS (ST1), LS (SQ1)], &
              & VSET=[NBSETLEV, NBSETLEV, NBSETSP, NBSETSP])

! Build list

U = [LG (GU), LG (GU1)]
V = [LG (GV), LG (GV1)]

VOR = [LS (SVOR), LS (SVOR1)]
DIV = [LS (SDIV), LS (SDIV1)]

VSETUV = [NBSETLEV, NBSETSP]

CALL INV_TRANS (U=U, V=V, VOR=VOR, DIV=DIV, VSETUV=VSETUV)

! Build list in two steps

! First step

U = [LG (GU)]
V = [LG (GV)]

VOR = [LS (SVOR)]
DIV = [LS (SDIV)]

VSETUV = [NBSETLEV]

! Append fields

U = [U, LG (GU1)]
V = [V, LG (GV1)]

VOR = [VOR, LS (SVOR1)]
DIV = [DIV, LS (SDIV1)]
VSETUV = [VSETUV, NBSETSP]

CALL INV_TRANS (U=U, V=V, VOR=VOR, DIV=DIV, VSETUV=VSETUV)

END 
