MODULE FIELD_MODULE

IMPLICIT NONE

TYPE FIELD_1RB
  REAL, POINTER :: P (:)
END TYPE

TYPE FIELD_2RB
  REAL, POINTER :: P (:,:)
END TYPE

TYPE FIELD_3RB
  REAL, POINTER :: P (:,:,:)
END TYPE

TYPE FIELD_1RB_VIEW
  REAL, POINTER :: V (:)
END TYPE

TYPE FIELD_2RB_VIEW
  REAL, POINTER :: V (:,:)
END TYPE

INTERFACE LG
  MODULE PROCEDURE ::        LG2RB, LG3RB
END INTERFACE

INTERFACE LS
  MODULE PROCEDURE :: LS1RB, LS2RB, LS3RB
END INTERFACE

INTERFACE FIELD_NEW
  MODULE PROCEDURE :: FIELD_NEW_1RB, FIELD_NEW_2RB, FIELD_NEW_3RB
END INTERFACE

CONTAINS

SUBROUTINE FIELD_NEW_1RB (YLF, UBOUNDS)

CLASS (FIELD_1RB), POINTER :: YLF
INTEGER :: UBOUNDS (1)

ALLOCATE (YLF)
ALLOCATE (YLF%P (UBOUNDS (1)))

END SUBROUTINE

SUBROUTINE FIELD_NEW_2RB (YLF, UBOUNDS)

CLASS (FIELD_2RB), POINTER :: YLF
INTEGER :: UBOUNDS (2)

ALLOCATE (YLF)
ALLOCATE (YLF%P (UBOUNDS (1), UBOUNDS (2)))

END SUBROUTINE

SUBROUTINE FIELD_NEW_3RB (YLF, UBOUNDS)

CLASS (FIELD_3RB), POINTER :: YLF
INTEGER :: UBOUNDS (3)

ALLOCATE (YLF)
ALLOCATE (YLF%P (UBOUNDS (1), UBOUNDS (2), UBOUNDS (3)))

END SUBROUTINE

FUNCTION LG2RB (YLF)

CLASS (FIELD_2RB), POINTER :: YLF

TYPE (FIELD_2RB_VIEW), ALLOCATABLE :: LG2RB (:)

REAL, POINTER :: ZZ2 (:,:)
INTEGER :: I2, I3, J

ZZ2 => YLF%P

ALLOCATE (LG2RB (1))

LG2RB (1)%V => ZZ2

END FUNCTION

FUNCTION LG3RB (YLF)

CLASS (FIELD_3RB), POINTER :: YLF

TYPE (FIELD_2RB_VIEW), ALLOCATABLE :: LG3RB (:)

REAL, POINTER :: ZZ3 (:,:,:)
INTEGER :: I2, J

ZZ3 => YLF%P

ALLOCATE (LG3RB (SIZE (ZZ3, 2)))

J = 1

DO I2 = LBOUND (ZZ3, 2), UBOUND (ZZ3, 2)
  LG3RB (J)%V => ZZ3 (:, I2, :)
  J = J + 1
ENDDO

END FUNCTION

FUNCTION LS1RB (YLF)

CLASS (FIELD_1RB), POINTER :: YLF

TYPE (FIELD_1RB_VIEW), ALLOCATABLE :: LS1RB (:)

REAL, POINTER :: ZZ1 (:)

ZZ1 => YLF%P

ALLOCATE (LS1RB (1))

LS1RB (1)%V => ZZ1 

END FUNCTION

FUNCTION LS2RB (YLF)

CLASS (FIELD_2RB), POINTER :: YLF

TYPE (FIELD_1RB_VIEW), ALLOCATABLE :: LS2RB (:)

REAL, POINTER :: ZZ2 (:,:)
INTEGER :: I2, I3, J

ZZ2 => YLF%P

ALLOCATE (LS2RB (SIZE (ZZ2, 2)))

J = 1

DO I2 = LBOUND (ZZ2, 2), UBOUND (ZZ2, 2)
  LS2RB (J)%V => ZZ2 (:, I2)
  J = J + 1
ENDDO

END FUNCTION

FUNCTION LS3RB (YLF)

CLASS (FIELD_3RB), POINTER :: YLF

TYPE (FIELD_1RB_VIEW), ALLOCATABLE :: LS3RB (:)

REAL, POINTER :: ZZ3 (:,:,:)
INTEGER :: I2, I3, J

ZZ3 => YLF%P

ALLOCATE (LS3RB (SIZE (ZZ3, 2) * SIZE (ZZ3, 3)))

J = 1

DO I3 = LBOUND (ZZ3, 3), UBOUND (ZZ3, 3)
  DO I2 = LBOUND (ZZ3, 2), UBOUND (ZZ3, 2)
    LS3RB (J)%V => ZZ3 (:, I2, I3)
    J = J + 1
  ENDDO
ENDDO

END FUNCTION

END MODULE

MODULE INV_TRANS_MODULE

USE FIELD_MODULE

CONTAINS

SUBROUTINE INV_TRANS (U, V, VOR, DIV)

TYPE (FIELD_2RB_VIEW) :: U (:), V (:)
TYPE (FIELD_1RB_VIEW) :: VOR (:), DIV (:)

IF ((SIZE (U) /= SIZE (V)) .OR. (SIZE (VOR) /= SIZE (DIV)) .OR.  (SIZE (U) /= SIZE (DIV))) THEN
  PRINT *, " U = ", SIZE (U)
  PRINT *, " V = ", SIZE (V)
  PRINT *, " VOR = ", SIZE (VOR)
  PRINT *, " DIV = ", SIZE (DIV)
  STOP 1
ENDIF

END SUBROUTINE

END MODULE

PROGRAM MAIN

USE FIELD_MODULE
USE INV_TRANS_MODULE

INTEGER, PARAMETER :: NPROMA = 100, NFLEVG = 15, NGPBLKS = 10, NSPEC2 = 600

CLASS (FIELD_3RB), POINTER :: FU, FV 
CLASS (FIELD_2RB), POINTER :: FVOR, FDIV

CLASS (FIELD_2RB), POINTER :: FU1, FV1
CLASS (FIELD_1RB), POINTER :: FVOR1, FDIV1

TYPE (FIELD_2RB_VIEW), ALLOCATABLE :: U (:), V (:)
TYPE (FIELD_1RB_VIEW), ALLOCATABLE :: VOR (:), DIV (:)

CALL FIELD_NEW (FU, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])
CALL FIELD_NEW (FV, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])

CALL FIELD_NEW (FVOR, UBOUNDS=[NSPEC2, NFLEVG])
CALL FIELD_NEW (FDIV, UBOUNDS=[NSPEC2, NFLEVG])

CALL FIELD_NEW (FU1, UBOUNDS=[NPROMA, NGPBLKS])
CALL FIELD_NEW (FV1, UBOUNDS=[NPROMA, NGPBLKS])

CALL FIELD_NEW (FVOR1, UBOUNDS=[NSPEC2])
CALL FIELD_NEW (FDIV1, UBOUNDS=[NSPEC2])

! Create list arguments

CALL INV_TRANS (U=[LG (FU), LG (FU1)], V=[LG (FV), LG (FV1)], VOR=[LS (FVOR), LS (FVOR1)], DIV=[LS (FDIV), LS (FDIV1)])

! Build list

U = [LG (FU), LG (FU1)]
V = [LG (FV), LG (FV1)]

VOR = [LS (FVOR), LS (FVOR1)]
DIV = [LS (FDIV), LS (FDIV1)]

CALL INV_TRANS (U=U, V=V, VOR=VOR, DIV=DIV)

! Build list in two steps

! First step

U = [LG (FU)]
V = [LG (FV)]

VOR = [LS (FVOR)]
DIV = [LS (FDIV)]

! Append fields

U = [U, LG (FU1)]
V = [V, LG (FV1)]

VOR = [VOR, LS (FVOR1)]
DIV = [DIV, LS (FDIV1)]

CALL INV_TRANS (U=U, V=V, VOR=VOR, DIV=DIV)

END 
