PROGRAM MAIN

USE FIELD_MODULE
USE INV_TRANS_FIELD_API_MODULE
USE PARKIND1  ,ONLY : JPIM     ,JPRB

IMPLICIT NONE

INTEGER(KIND=JPIM), PARAMETER :: NPRTRW = 5, NPRTRV = 3, MYSETW = 1, MYSETV = 1

INTEGER(KIND=JPIM), PARAMETER :: NPROMA = 100, NFLEVG = 15, NGPBLKS = 10, NSPEC2 = 600, NFIELDS = 7
INTEGER(KIND=JPIM) :: NFLEVL 

CLASS (FIELD_3RB), POINTER :: YLU, YLV              !A vector field in grid space(US,VS) 
CLASS (FIELD_3RB), POINTER :: YLT, YLQ              !Two scalar fields in grid space T and Q
CLASS (FIELD_2RB), POINTER :: YLSPVOR, YLSPDIV      !A Vector field in spectral space(YLSPVOR,SPDIVS)
CLASS (FIELD_2RB), POINTER :: YLSPT, YLSPQ          !Two scalar fields in spectral space ST and SQ

CLASS (FIELD_2RB), POINTER :: YLU1, YLV1            !A surfacic vector field in grid space(GU1,GV1) 
CLASS (FIELD_2RB), POINTER :: YLT1, YLQ1            !Two surfacic scalar fields in grid space GT1 and GQ1
CLASS (FIELD_1RB), POINTER :: YLSPVOR1, YLSPDIV1    !A surfacic vector field in spectral space(SPVOR1,SPDIV1)
CLASS (FIELD_1RB), POINTER :: YLSPT1, YLSPQ1        !Two surfacic scalar fields in spectral space ST1 and SQ1

CLASS (FIELD_4RB), POINTER :: YLU2, YLV2            !A surfacic vector field in grid space(GU1,GV1) 
CLASS (FIELD_4RB), POINTER :: YLT2, YLQ2            !Two surfacic scalar fields in grid space GT1 and GQ1
CLASS (FIELD_3RB), POINTER :: YLSPVOR2, YLSPDIV2    !A surfacic vector field in spectral space(SPVOR1,SPDIV1)
CLASS (FIELD_3RB), POINTER :: YLSPT2, YLSPQ2        !Two surfacic scalar fields in spectral space ST1 and SQ1

! Derivatives
CLASS (FIELD_3RB), POINTER :: YLDU, YLDV              
CLASS (FIELD_3RB), POINTER :: YLDTEW, YLDQEW          
CLASS (FIELD_3RB), POINTER :: YLDTNS, YLDQNS          

CLASS (FIELD_2RB), POINTER :: YLDU1, YLDV1            
CLASS (FIELD_2RB), POINTER :: YLDT1EW, YLDQ1EW        
CLASS (FIELD_2RB), POINTER :: YLDT1NS, YLDQ1NS        

CLASS (FIELD_4RB), POINTER :: YLDU2, YLDV2
CLASS (FIELD_4RB), POINTER :: YLDT2EW, YLDQ2EW
CLASS (FIELD_4RB), POINTER :: YLDT2NS, YLDQ2NS

! Vorticity and divergence
CLASS (FIELD_3RB), POINTER :: YLUVDIV
CLASS (FIELD_2RB), POINTER :: YLUV1DIV
CLASS (FIELD_4RB), POINTER :: YLUV2DIV

CLASS (FIELD_3RB), POINTER :: YLUVVOR
CLASS (FIELD_2RB), POINTER :: YLUV1VOR
CLASS (FIELD_4RB), POINTER :: YLUV2VOR

TYPE (FIELD_BASIC_PTR), ALLOCATABLE :: US (:), VS (:)         !The lists of vector field view in grid space
TYPE (FIELD_BASIC_PTR), ALLOCATABLE :: SCALARS (:)            !The lists of scalar field view in grid space
TYPE (FIELD_BASIC_PTR), ALLOCATABLE :: SPVORS (:), SPDIVS (:) !The lists of vector fields view in spectral space
TYPE (FIELD_BASIC_PTR), ALLOCATABLE :: SPSCALARS (:)          !The lists of scalar fields view in spectral space

INTEGER(KIND=JPIM), ALLOCATABLE :: NBSETLEV  (:)               !Meta data
INTEGER(KIND=JPIM), ALLOCATABLE :: NBSETLEV2 (:)               !Meta data
INTEGER(KIND=JPIM), ALLOCATABLE :: VSETUVS (:), VSETS (:)     !Meta data

PROCEDURE (FSPGL_INTF), POINTER :: FSPGL_PROC => NULL ()

INTEGER(KIND=JPIM) :: JLEV, JFLD, J
INTEGER(KIND=JPIM) :: NBSETSP
LOGICAL :: LLACC

PRINT *, " ECTRANS with FIELD_API - 0.1 "

NBSETSP = 1

!Create meta data

!Create meta data
ALLOCATE (NBSETLEV (NFLEVG))
  DO JLEV = 1, NFLEVG
    NBSETLEV (JLEV) = 1 + ((JLEV-1) * (NPRTRV)) / NFLEVG
ENDDO

ALLOCATE (NBSETLEV2 (NFLEVG*NFIELDS))
J = 1
DO JFLD = 1, NFIELDS
  DO JLEV = 1, NFLEVG
    NBSETLEV2 (J) = 1 + ((JLEV-1) * (NPRTRV)) / NFLEVG
    J=J+1
  ENDDO
ENDDO

NFLEVL = COUNT (NBSETLEV == MYSETV)

! Create input spectral fields
CALL FIELD_NEW(YLSPVOR1, UBOUNDS=[NSPEC2])
CALL FIELD_NEW(YLSPDIV1, UBOUNDS=[NSPEC2])
CALL FIELD_NEW(YLSPT1, UBOUNDS=[NSPEC2, NFLEVL])
CALL FIELD_NEW(YLSPQ1, UBOUNDS=[NSPEC2, NFLEVL])

CALL FIELD_NEW(YLSPVOR, UBOUNDS=[NSPEC2, NFLEVL])
CALL FIELD_NEW(YLSPDIV, UBOUNDS=[NSPEC2, NFLEVL])
CALL FIELD_NEW(YLSPT, UBOUNDS=[NSPEC2, NFLEVL])
CALL FIELD_NEW(YLSPQ, UBOUNDS=[NSPEC2, NFLEVL])

CALL FIELD_NEW(YLSPVOR2, UBOUNDS=[NSPEC2, NFIELDS, NFLEVL])
CALL FIELD_NEW(YLSPDIV2, UBOUNDS=[NSPEC2, NFIELDS, NFLEVL])
CALL FIELD_NEW(YLSPT2, UBOUNDS=[NSPEC2, NFIELDS, NFLEVL])
CALL FIELD_NEW(YLSPQ2, UBOUNDS=[NSPEC2, NFIELDS, NFLEVL])

! Create output grid-point fields
CALL FIELD_NEW(YLU1, UBOUNDS=[NPROMA, NGPBLKS])
CALL FIELD_NEW(YLV1, UBOUNDS=[NPROMA, NGPBLKS])
CALL FIELD_NEW(YLT1, UBOUNDS=[NPROMA, NGPBLKS])
CALL FIELD_NEW(YLQ1, UBOUNDS=[NPROMA, NGPBLKS])

CALL FIELD_NEW(YLU, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])
CALL FIELD_NEW(YLV, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])
CALL FIELD_NEW(YLT, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])
CALL FIELD_NEW(YLQ, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])

CALL FIELD_NEW(YLU2, UBOUNDS=[NPROMA, NFLEVG, NFIELDS, NGPBLKS])
CALL FIELD_NEW(YLV2, UBOUNDS=[NPROMA, NFLEVG, NFIELDS, NGPBLKS])
CALL FIELD_NEW(YLT2, UBOUNDS=[NPROMA, NFLEVG, NFIELDS, NGPBLKS])
CALL FIELD_NEW(YLQ2, UBOUNDS=[NPROMA, NFLEVG, NFIELDS, NGPBLKS])

! Create output grid-point derivatives
CALL FIELD_NEW(YLDU1, UBOUNDS=[NPROMA, NGPBLKS])
CALL FIELD_NEW(YLDV1, UBOUNDS=[NPROMA, NGPBLKS])
CALL FIELD_NEW(YLDT1EW, UBOUNDS=[NPROMA, NGPBLKS])
CALL FIELD_NEW(YLDQ1EW, UBOUNDS=[NPROMA, NGPBLKS])
CALL FIELD_NEW(YLDT1NS, UBOUNDS=[NPROMA, NGPBLKS])
CALL FIELD_NEW(YLDQ1NS, UBOUNDS=[NPROMA, NGPBLKS])

CALL FIELD_NEW(YLDU, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])
CALL FIELD_NEW(YLDV, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])
CALL FIELD_NEW(YLDTEW, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])
CALL FIELD_NEW(YLDQEW, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])
CALL FIELD_NEW(YLDTNS, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])
CALL FIELD_NEW(YLDQNS, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])

CALL FIELD_NEW(YLDU2, UBOUNDS=[NPROMA, NFLEVG, NFIELDS, NGPBLKS])
CALL FIELD_NEW(YLDV2, UBOUNDS=[NPROMA, NFLEVG, NFIELDS, NGPBLKS])
CALL FIELD_NEW(YLDT2EW, UBOUNDS=[NPROMA, NFLEVG, NFIELDS, NGPBLKS])
CALL FIELD_NEW(YLDQ2EW, UBOUNDS=[NPROMA, NFLEVG, NFIELDS, NGPBLKS])
CALL FIELD_NEW(YLDT2NS, UBOUNDS=[NPROMA, NFLEVG, NFIELDS, NGPBLKS])
CALL FIELD_NEW(YLDQ2NS, UBOUNDS=[NPROMA, NFLEVG, NFIELDS, NGPBLKS])

! Create output vorticity and divergence
CALL FIELD_NEW(YLUV1VOR, UBOUNDS=[NPROMA, NGPBLKS])
CALL FIELD_NEW(YLUV1DIV, UBOUNDS=[NPROMA, NGPBLKS])

CALL FIELD_NEW(YLUVVOR, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])
CALL FIELD_NEW(YLUVDIV, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])

CALL FIELD_NEW(YLUV2VOR, UBOUNDS=[NPROMA, NFLEVG, NFIELDS, NGPBLKS])
CALL FIELD_NEW(YLUV2DIV, UBOUNDS=[NPROMA, NFLEVG, NFIELDS, NGPBLKS])

! Create list arguments
PRINT*,"CALL 1"

FSPGL_PROC => NULL ()

CALL INV_TRANS_FIELD_API (SPVORS=[B(YLSPVOR), B(YLSPVOR1), B(YLSPVOR2)], SPDIVS=[B(YLSPDIV), B(YLSPDIV1), B(YLSPDIV2)], &
                        & SPSCALARS=[B(YLSPT), B(YLSPQ), B(YLSPT1), B(YLSPQ1), B(YLSPT2), B(YLSPQ2)], &
                        & US=[B(YLU), B(YLU1), B(YLU2)],  VS=[B(YLV), B(YLV1), B(YLV2)], &
                        & SCALARS=[B(YLT), B(YLQ), B(YLT1), B(YLQ1), B(YLT2), B(YLQ2)], & 
                        & VSETUVS=[NBSETLEV, NBSETSP, NBSETLEV2], &
                        & VSETS=[NBSETLEV, NBSETLEV, NBSETSP, NBSETSP, NBSETLEV2, NBSETLEV2], &
			                  & LDACC=LLACC, FSPGL_PROC=FSPGL_PROC)  !  FSPGL_PROC not PRESENT, because it is NULL associated


! Build list

US = [B(YLU), B(YLU1), B(YLU2)]
VS = [B(YLV), B(YLV1), B(YLV2)]

SPVORS = [B(YLSPVOR), B(YLSPVOR1), B(YLSPVOR2)]
SPDIVS = [B(YLSPDIV), B(YLSPDIV1), B(YLSPDIV2)]

VSETUVS = [NBSETLEV, NBSETSP, NBSETLEV2]

SCALARS = [B(YLT), B(YLQ), B(YLT1), B(YLQ1), B(YLT2), B(YLQ2)]
SPSCALARS = [B(YLSPT), B(YLSPQ), B(YLSPT1), B(YLSPQ1), B(YLSPT2), B(YLSPQ2)]
VSETS = [NBSETLEV, NBSETLEV, NBSETSP, NBSETSP, NBSETLEV2, NBSETLEV2]

PRINT*,"CALL 2"
CALL INV_TRANS_FIELD_API (SPVORS=SPVORS, SPDIVS=SPDIVS,  SPSCALARS=SPSCALARS, &
                        US=US, VS=VS,  SCALARS=SCALARS,VSETUVS=VSETUVS, VSETS=VSETS, LDACC=LLACC)

! Build list in two steps

! First step : 3D fields

US = [B(YLU)]
VS = [B(YLV)]

SPVORS = [B(YLSPVOR)]
SPDIVS = [B(YLSPDIV)]

VSETUVS = [NBSETLEV]

SCALARS = [B(YLT), B(YLQ)]
SPSCALARS = [B(YLSPT), B(YLSPQ)]

! Append surface fields

US = [US, B(YLU1), B(YLU2)]
VS = [VS, B(YLV1), B(YLV2)]

SPVORS = [SPVORS, B(YLSPVOR1), B(YLSPVOR2)]
SPDIVS = [SPDIVS, B(YLSPDIV1), B(YLSPDIV2)]
VSETUVS = [VSETUVS, NBSETSP, NBSETLEV2]

SCALARS = [SCALARS, B(YLT1), B(YLQ1), B(YLT2), B(YLQ2)]
SPSCALARS = [SPSCALARS, B(YLSPT1), B(YLSPQ1), B(YLSPT2), B(YLSPQ2)]

PRINT*,"CALL 3"

FSPGL_PROC => FSPGL

CALL INV_TRANS_FIELD_API (SPVORS=SPVORS, SPDIVS=SPDIVS,  SPSCALARS=SPSCALARS, &
                          & US=US, VS=VS,  SCALARS=SCALARS,&
                          & VSETUVS=VSETUVS,&
                          & VSETS=VSETS, LDACC=LLACC,&
                          & FSPGL_PROC=FSPGL_PROC)



PRINT*,"CALL 4: adding derivatives and vorticity and divergence"

FSPGL_PROC => FSPGL

  CALL INV_TRANS_FIELD_API (SPVORS=[B(YLSPVOR), B(YLSPVOR1), B(YLSPVOR2)], SPDIVS=[B(YLSPDIV), B(YLSPDIV1), B(YLSPDIV2)], &
                          & SPSCALARS=[B(YLSPT), B(YLSPQ), B(YLSPT1), B(YLSPQ1), B(YLSPT2), B(YLSPQ2)], &
                          & US=[B(YLU), B(YLU1), B(YLU2)],  VS=[B(YLV), B(YLV1), B(YLV2)], &
                          & VORS=[B(YLUVVOR), B(YLUV1VOR),B(YLUV2VOR)],  DIVS=[B(YLUVDIV), B(YLUV1DIV), B(YLUV2DIV)], &
                          & SCALARS=[B(YLT), B(YLQ), B(YLT1), B(YLQ1), B(YLT2), B(YLQ2)], & 
                          & DUS=[B(YLDU), B(YLDU1), B(YLDU2)],  DVS=[B(YLDV), B(YLDV1), B(YLDV2)], &                        
                          & DSCALARSEW=[B(YLDTEW), B(YLDQEW), B(YLDT1EW), B(YLDQ1EW), B(YLDT2EW), B(YLDQ2EW)], &                        
                          & DSCALARSNS=[B(YLDTNS), B(YLDQNS), B(YLDT1NS), B(YLDQ1NS), B(YLDT2NS), B(YLDQ2NS)], &                        
                          & VSETUVS=[NBSETLEV, NBSETSP,NBSETLEV2 ], &
                          & VSETS=[NBSETLEV, NBSETLEV, NBSETSP, NBSETSP,NBSETLEV2, NBSETLEV2], &
                          & LDACC=LLACC, FSPGL_PROC=FSPGL_PROC, LDVERBOSE =.TRUE.)  !  FSPGL_PROC not PRESENT, because it is NULL associated


CONTAINS

SUBROUTINE FSPGL (KM,KSL,KDGL,KFIELDS,PR1MU2,PFIELD,&
                & KPTRU,KFLDUV,KFLDSC,KFLDPTRUV)

INTEGER(KIND=JPIM),INTENT(IN)           :: KM
INTEGER(KIND=JPIM),INTENT(IN)           :: KSL
INTEGER(KIND=JPIM),INTENT(IN)           :: KDGL
REAL(KIND=JPRB)   ,INTENT(IN)           :: PR1MU2(KDGL)
INTEGER(KIND=JPIM),INTENT(IN)           :: KFIELDS
REAL(KIND=JPRB)   ,INTENT(INOUT),TARGET :: PFIELD(2*KFIELDS,0:KDGL+1)
INTEGER(KIND=JPIM),INTENT(IN)           :: KPTRU
INTEGER(KIND=JPIM),INTENT(IN)           :: KFLDUV
INTEGER(KIND=JPIM),INTENT(IN)           :: KFLDSC
INTEGER(KIND=JPIM),INTENT(IN)           :: KFLDPTRUV(KFLDUV)

PRINT *,"EXECUTING FSPGL"
END SUBROUTINE FSPGL

END 
