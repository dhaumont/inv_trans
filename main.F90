PROGRAM MAIN

USE FIELD_MODULE
USE INV_TRANS_FIELD_API_MODULE
USE PARKIND1  ,ONLY : JPIM     ,JPRB

IMPLICIT NONE

INTEGER(KIND=JPIM), PARAMETER :: NPRTRW = 5, NPRTRV = 3, MYSETW = 1, MYSETV = 1

INTEGER(KIND=JPIM), PARAMETER :: NPROMA = 100, NFLEVG = 15, NGPBLKS = 10, NSPEC2 = 600
INTEGER(KIND=JPIM) :: NFLEVL 

CLASS (FIELD_3RB), POINTER :: YLU, YLV              !A vector field in grid space(US,VS) 
CLASS (FIELD_3RB), POINTER :: YLT, YLQ              !Two scalar fields in grid space T and Q
CLASS (FIELD_2RB), POINTER :: YLSPVOR, YLSPDIV        !A Vector field in spectral space(YLSPVOR,SPDIVS)
CLASS (FIELD_2RB), POINTER :: YLSPT, YLSPQ              !Two scalar fields in spectral space ST and SQ

CLASS (FIELD_2RB), POINTER :: YLU1, YLV1            !A surfacic vector field in grid space(GU1,GV1) 
CLASS (FIELD_2RB), POINTER :: YLT1, YLQ1            !Two surfacic scalar fields in grid space GT1 and GQ1
CLASS (FIELD_1RB), POINTER :: YLSPVOR1, YLSPDIV1        !A surfacic vector field in spectral space(SPVOR1,SPDIV1)
CLASS (FIELD_1RB), POINTER :: YLSPT1, YLSPQ1            !Two surfacic scalar fields in spectral space ST1 and SQ1

TYPE (FIELD_BASIC_PTR), ALLOCATABLE :: US (:), VS (:)     !The lists of vector field view in grid space
TYPE (FIELD_BASIC_PTR), ALLOCATABLE :: SCALARS (:)         !The lists of scalar field view in grid space
TYPE (FIELD_BASIC_PTR), ALLOCATABLE :: SPVORS (:), SPDIVS (:) !The lists of vector fields view in spectral space
TYPE (FIELD_BASIC_PTR), ALLOCATABLE :: SPSCALARS (:)         !The lists of scalar fields view in spectral space

INTEGER(KIND=JPIM), ALLOCATABLE :: NBSETLEV (:)          !Meta data
INTEGER(KIND=JPIM), ALLOCATABLE :: VSETUVS (:), VSETS (:) !Meta data

PROCEDURE (FSPGL_INTF), POINTER :: FSPGL_PROC => NULL ()

INTEGER(KIND=JPIM) :: JLEV
INTEGER(KIND=JPIM) :: NBSETSP
LOGICAL :: LLACC

PRINT *, " ECTRANS with FIELD_API - 0.1 "

NBSETSP = 1

!Create meta data
ALLOCATE (NBSETLEV (NFLEVG))

DO JLEV = 1, NFLEVG
  NBSETLEV (JLEV) = 1 + ((JLEV-1) * (NPRTRV)) / NFLEVG
ENDDO

NFLEVL = COUNT (NBSETLEV == MYSETV)

! Create fields
CALL FIELD_NEW(YLU, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])
CALL FIELD_NEW(YLV, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])
CALL FIELD_NEW(YLT, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])
CALL FIELD_NEW(YLQ, UBOUNDS=[NPROMA, NFLEVG, NGPBLKS])

CALL FIELD_NEW(YLSPVOR, UBOUNDS=[NSPEC2, NFLEVL])
CALL FIELD_NEW(YLSPDIV, UBOUNDS=[NSPEC2, NFLEVL])
CALL FIELD_NEW(YLSPT, UBOUNDS=[NSPEC2, NFLEVL])
CALL FIELD_NEW(YLSPQ, UBOUNDS=[NSPEC2, NFLEVL])

CALL FIELD_NEW(YLU1, UBOUNDS=[NPROMA, NGPBLKS])
CALL FIELD_NEW(YLV1, UBOUNDS=[NPROMA, NGPBLKS])
CALL FIELD_NEW(YLT1, UBOUNDS=[NPROMA, NGPBLKS])
CALL FIELD_NEW(YLQ1, UBOUNDS=[NPROMA, NGPBLKS])

CALL FIELD_NEW(YLSPVOR1, UBOUNDS=[NSPEC2])
CALL FIELD_NEW(YLSPDIV1, UBOUNDS=[NSPEC2])
CALL FIELD_NEW(YLSPT1, UBOUNDS=[NSPEC2, NFLEVL])
CALL FIELD_NEW(YLSPQ1, UBOUNDS=[NSPEC2, NFLEVL])

! Create list arguments
PRINT*,"CALL 1"

FSPGL_PROC => NULL ()

CALL INV_TRANS_FIELD_API (SPVORS=[B(YLSPVOR), B(YLSPVOR1)], SPDIVS=[B(YLSPDIV), B(YLSPDIV1)], &
                        & SPSCALARS=[B(YLSPT), B(YLSPQ), B(YLSPT1), B(YLSPQ1)], &
                        & US=[B(YLU), B(YLU1)],  VS=[B(YLV), B(YLV1)], &                        
                        & SCALARS=[B(YLT), B(YLQ), B(YLT1), B(YLQ1)], &                        
                        & VSETUVS=[NBSETLEV, NBSETSP], &
                        & VSETS=[NBSETLEV, NBSETLEV, NBSETSP, NBSETSP], &
			                  & LDACC=LLACC, FSPGL_PROC=FSPGL_PROC)  !  FSPGL_PROC not PRESENT, because it is NULL associated


! Build list

US = [B(YLU), B(YLU1)]
VS = [B(YLV), B(YLV1)]

SPVORS = [B(YLSPVOR), B(YLSPVOR1)]
SPDIVS = [B(YLSPDIV), B(YLSPDIV1)]

VSETUVS = [NBSETLEV, NBSETSP]

SCALARS = [B(YLT), B(YLQ), B(YLT1), B(YLQ1)]
SPSCALARS = [B(YLSPT), B(YLSPQ), B(YLSPT1), B(YLSPQ1)]
VSETS = [NBSETLEV, NBSETLEV, NBSETSP, NBSETSP]

PRINT*,"CALL 2"
CALL INV_TRANS_FIELD_API (SPVORS=SPVORS, SPDIVS=SPDIVS,  SPSCALARS=SPSCALARS, &
                        US=US, VS=VS,  SCALARS=SCALARS,VSETUVS=VSETUVS, VSETS=VSETS, LDACC=LLACC)

! Build list in two steps

! First step : 3D fields

US = [B(YLU)]
VS = [B(YLV)]

SPVORS = [B(YLSPVOR)]
SPDIVS = [B(YLSPDIV)]

VSETUVS = [NBSETLEV]

SCALARS = [B(YLT), B(YLQ)]
SPSCALARS = [B(YLSPT), B(YLSPQ)]

! Append surface fields

US = [US, B(YLU1)]
VS = [VS, B(YLV1)]

SPVORS = [SPVORS, B(YLSPVOR1)]
SPDIVS = [SPDIVS, B(YLSPDIV1)]
VSETUVS = [VSETUVS, NBSETSP]

SCALARS = [SCALARS, B(YLT1), B(YLQ1)]
SPSCALARS = [SPSCALARS, B(YLSPT1), B(YLSPQ1)]

PRINT*,"CALL 3"

FSPGL_PROC => FSPGL

CALL INV_TRANS_FIELD_API (SPVORS=SPVORS, SPDIVS=SPDIVS,  SPSCALARS=SPSCALARS, &
                          & US=US, VS=VS,  SCALARS=SCALARS,&
                          & VSETUVS=VSETUVS,&
                          & VSETS=VSETS, LDACC=LLACC,&
                          & FSPGL_PROC=FSPGL_PROC)


CONTAINS

SUBROUTINE FSPGL (KM,KSL,KDGL,KFIELDS,PR1MU2,PFIELD,&
                & KPTRU,KFLDUV,KFLDSC,KFLDPTRUV)

INTEGER(KIND=JPIM),INTENT(IN)           :: KM
INTEGER(KIND=JPIM),INTENT(IN)           :: KSL
INTEGER(KIND=JPIM),INTENT(IN)           :: KDGL
REAL(KIND=JPRB)   ,INTENT(IN)           :: PR1MU2(KDGL)
INTEGER(KIND=JPIM),INTENT(IN)           :: KFIELDS
REAL(KIND=JPRB)   ,INTENT(INOUT),TARGET :: PFIELD(2*KFIELDS,0:KDGL+1)
INTEGER(KIND=JPIM),INTENT(IN)           :: KPTRU
INTEGER(KIND=JPIM),INTENT(IN)           :: KFLDUV
INTEGER(KIND=JPIM),INTENT(IN)           :: KFLDSC
INTEGER(KIND=JPIM),INTENT(IN)           :: KFLDPTRUV(KFLDUV)

PRINT *,"CALLING FSPGL",KM,KSL,KDGL,KFIELDS, &
                      & KPTRU,KFLDUV,KFLDSC
END SUBROUTINE FSPGL

END 
