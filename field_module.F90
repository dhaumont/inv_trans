MODULE FIELD_MODULE
!Mockup of field API
  USE PARKIND1  ,ONLY : JPIM     ,JPRB

  IMPLICIT NONE
  
  TYPE FIELD_BASIC
  
  END TYPE
  
  TYPE FIELD_BASIC_PTR
    CLASS (FIELD_BASIC), POINTER :: PTR
  END TYPE
  
  TYPE, EXTENDS (FIELD_BASIC) ::  FIELD_1RB
    REAL(KIND=JPRB), POINTER :: P (:)
  CONTAINS
    PROCEDURE :: GET_DIMS => GET_DIMS_1RB
  END TYPE
  
  TYPE, EXTENDS (FIELD_BASIC) ::  FIELD_2RB
    REAL(KIND=JPRB), POINTER :: P (:,:)
  CONTAINS
    PROCEDURE :: GET_DIMS => GET_DIMS_2RB
  END TYPE
  
  TYPE, EXTENDS (FIELD_BASIC) ::  FIELD_3RB
    REAL(KIND=JPRB), POINTER :: P (:,:,:)
  CONTAINS
    PROCEDURE :: GET_DIMS => GET_DIMS_3RB
  END TYPE
  
  TYPE, EXTENDS (FIELD_BASIC) ::  FIELD_4RB
    REAL(KIND=JPRB), POINTER :: P (:,:,:,:)
  CONTAINS
    PROCEDURE :: GET_DIMS => GET_DIMS_4RB
  END TYPE
  
  TYPE FIELD_1RB_VIEW
    REAL(KIND=JPRB), POINTER :: V (:)
  END TYPE
  
  TYPE FIELD_2RB_VIEW
    REAL(KIND=JPRB), POINTER :: V (:,:)
  END TYPE
  
  INTERFACE B
    MODULE PROCEDURE :: B1RB, B2RB, B3RB, B4RB
  END INTERFACE
  
  INTERFACE FIELD_NEW
    MODULE PROCEDURE :: FIELD_NEW_1RB, FIELD_NEW_2RB, FIELD_NEW_3RB, FIELD_NEW_4RB
  END INTERFACE
  
  CONTAINS
  
  SUBROUTINE GET_DIMS_1RB (SELF, LBOUNDS, UBOUNDS)
  CLASS (FIELD_1RB) :: SELF
  INTEGER(KIND=JPIM), OPTIONAL :: LBOUNDS (:), UBOUNDS (:)
  IF (PRESENT (LBOUNDS)) LBOUNDS = LBOUND (SELF%P)
  IF (PRESENT (UBOUNDS)) UBOUNDS = UBOUND (SELF%P)
  END SUBROUTINE
  
  SUBROUTINE GET_DIMS_2RB (SELF, LBOUNDS, UBOUNDS)
  CLASS (FIELD_2RB) :: SELF
  INTEGER(KIND=JPIM), OPTIONAL :: LBOUNDS (:), UBOUNDS (:)
  IF (PRESENT (LBOUNDS)) LBOUNDS = LBOUND (SELF%P)
  IF (PRESENT (UBOUNDS)) UBOUNDS = UBOUND (SELF%P)
  END SUBROUTINE
  
  SUBROUTINE GET_DIMS_3RB (SELF, LBOUNDS, UBOUNDS)
  CLASS (FIELD_3RB) :: SELF
  INTEGER(KIND=JPIM), OPTIONAL :: LBOUNDS (:), UBOUNDS (:)
  IF (PRESENT (LBOUNDS)) LBOUNDS = LBOUND (SELF%P)
  IF (PRESENT (UBOUNDS)) UBOUNDS = UBOUND (SELF%P)
  END SUBROUTINE
  
  SUBROUTINE GET_DIMS_4RB (SELF, LBOUNDS, UBOUNDS)
    CLASS (FIELD_4RB) :: SELF
    INTEGER(KIND=JPIM), OPTIONAL :: LBOUNDS (:), UBOUNDS (:)
    IF (PRESENT (LBOUNDS)) LBOUNDS = LBOUND (SELF%P)
    IF (PRESENT (UBOUNDS)) UBOUNDS = UBOUND (SELF%P)
    END SUBROUTINE
    

  FUNCTION B1RB (YLF)
  
  CLASS (FIELD_1RB), POINTER :: YLF
  TYPE (FIELD_BASIC_PTR) :: B1RB
  
  B1RB%PTR => YLF
  
  END FUNCTION
  
  FUNCTION B2RB (YLF)
  
  CLASS (FIELD_2RB), POINTER :: YLF
  TYPE (FIELD_BASIC_PTR) :: B2RB
  
  B2RB%PTR => YLF
  
  END FUNCTION
  
  FUNCTION B3RB (YLF)
  
  CLASS (FIELD_3RB), POINTER :: YLF
  TYPE (FIELD_BASIC_PTR) :: B3RB
  
  B3RB%PTR => YLF
  
  END FUNCTION
  
  FUNCTION B4RB (YLF)
  
    CLASS (FIELD_4RB), POINTER :: YLF
    TYPE (FIELD_BASIC_PTR) :: B4RB
    
    B4RB%PTR => YLF
    
    END FUNCTION
    
  SUBROUTINE FIELD_NEW_1RB (YLF, UBOUNDS)
  
  CLASS (FIELD_1RB), POINTER :: YLF
  INTEGER(KIND=JPIM) :: UBOUNDS (1)
  
  ALLOCATE (YLF)
  ALLOCATE (YLF%P (UBOUNDS (1)))
  
  END SUBROUTINE
  
  SUBROUTINE FIELD_NEW_2RB (YLF, UBOUNDS)
  
  CLASS (FIELD_2RB), POINTER :: YLF
  INTEGER(KIND=JPIM) :: UBOUNDS (2)
  
  ALLOCATE (YLF)
  ALLOCATE (YLF%P (UBOUNDS (1), UBOUNDS (2)))
  
  END SUBROUTINE
  
  SUBROUTINE FIELD_NEW_3RB (YLF, UBOUNDS)
  
  CLASS (FIELD_3RB), POINTER :: YLF
  INTEGER(KIND=JPIM) :: UBOUNDS (3)
  
  ALLOCATE (YLF)
  ALLOCATE (YLF%P (UBOUNDS (1), UBOUNDS (2), UBOUNDS (3)))
  
  END SUBROUTINE
  
  SUBROUTINE FIELD_NEW_4RB (YLF, UBOUNDS)
  
    CLASS (FIELD_4RB), POINTER :: YLF
    INTEGER(KIND=JPIM) :: UBOUNDS (4)
    
    ALLOCATE (YLF)
    ALLOCATE (YLF%P (UBOUNDS (1), UBOUNDS (2), UBOUNDS (3), UBOUNDS (4)))
    
  END SUBROUTINE
    
  FUNCTION LG2RB (YLF, LDACC)
  
  CLASS (FIELD_2RB), POINTER, INTENT (IN) :: YLF
  LOGICAL, OPTIONAL :: LDACC
  
  TYPE (FIELD_2RB_VIEW), ALLOCATABLE :: LG2RB (:)
  
  REAL(KIND=JPRB), POINTER :: ZZ2 (:,:)
  INTEGER(KIND=JPIM) :: I2, I3, J
  
  ZZ2 => YLF%P
  
  ALLOCATE (LG2RB (1))
  
  LG2RB (1)%V => ZZ2
  
  END FUNCTION
  
  FUNCTION LG3RB (YLF, LDACC)
  
  CLASS (FIELD_3RB), POINTER, INTENT (IN) :: YLF
  LOGICAL, OPTIONAL :: LDACC
  
  TYPE (FIELD_2RB_VIEW), ALLOCATABLE :: LG3RB (:)
  
  REAL(KIND=JPRB), POINTER :: ZZ3 (:,:,:)
  INTEGER(KIND=JPIM) :: I2, J
  
  ZZ3 => YLF%P
  
  ALLOCATE (LG3RB (SIZE (ZZ3, 2)))
  
  J = 1
  
  DO I2 = LBOUND (ZZ3, 2), UBOUND (ZZ3, 2)
    LG3RB (J)%V => ZZ3 (:, I2, :)
    J = J + 1
  ENDDO
  
  END FUNCTION
  
  FUNCTION LG4RB (YLF, LDACC)
  
    CLASS (FIELD_4RB), POINTER, INTENT (IN) :: YLF
    LOGICAL, OPTIONAL :: LDACC
    
    TYPE (FIELD_2RB_VIEW), ALLOCATABLE :: LG4RB (:)
    
    REAL(KIND=JPRB), POINTER :: ZZ4 (:,:,:,:)
    INTEGER(KIND=JPIM) :: I2, I3, J
    
    ZZ4 => YLF%P
    
    ALLOCATE (LG4RB (SIZE (ZZ4, 2) * SIZE (ZZ4, 3)))
    
    J = 1
    
    DO I3 = LBOUND (ZZ4, 3), UBOUND (ZZ4, 3)
      DO I2 = LBOUND (ZZ4, 2), UBOUND (ZZ4, 2)
        LG4RB (J)%V => ZZ4(:, I2, I3, :)
        J = J + 1
      ENDDO
    ENDDO

    END FUNCTION
    
  FUNCTION LG (YLFL, LDACC)
  
  TYPE (FIELD_BASIC_PTR) :: YLFL (:)
  LOGICAL, OPTIONAL :: LDACC
  
  TYPE (FIELD_2RB_VIEW), ALLOCATABLE :: LG (:)
  
  INTEGER(KIND=JPIM) :: IOFF, ILEN, JFLD, JPASS
  INTEGER(KIND=JPIM) :: ILBOUNDS (5), IUBOUNDS (5)
  
  DO JPASS = 1, 2
  
    IOFF = 0
    
    DO JFLD = 1, SIZE (YLFL)
    
      SELECT TYPE (YLF => YLFL (JFLD)%PTR)
        CLASS IS (FIELD_2RB)
          CALL YLF%GET_DIMS (LBOUNDS=ILBOUNDS, UBOUNDS=IUBOUNDS)
          ILEN = 1
          IF (JPASS == 2) LG (IOFF+1:IOFF+ILEN) = LG2RB (YLF, LDACC)
        CLASS IS (FIELD_3RB)
          CALL YLF%GET_DIMS (LBOUNDS=ILBOUNDS, UBOUNDS=IUBOUNDS)
          ILEN = (IUBOUNDS (2) - ILBOUNDS (2) + 1)
          IF (JPASS == 2) LG (IOFF+1:IOFF+ILEN) = LG3RB (YLF, LDACC)
        CLASS IS (FIELD_4RB)
          CALL YLF%GET_DIMS (LBOUNDS=ILBOUNDS, UBOUNDS=IUBOUNDS)
          ILEN = (IUBOUNDS (2) - ILBOUNDS (2) + 1) * (IUBOUNDS (3) - ILBOUNDS (3) + 1)
          IF (JPASS == 2) LG (IOFF+1:IOFF+ILEN) = LG4RB (YLF, LDACC)
        CLASS DEFAULT
          STOP 1
      END SELECT
  
      IOFF = IOFF + ILEN
    
    ENDDO
  
    IF (JPASS == 1) THEN
      ALLOCATE (LG (IOFF))
    ENDIF
  
  ENDDO
  
  END FUNCTION LG
  
  FUNCTION LS1RB (YLF, LDACC)
  
  CLASS (FIELD_1RB), POINTER, INTENT (IN) :: YLF
  LOGICAL, OPTIONAL :: LDACC
  
  TYPE (FIELD_1RB_VIEW), ALLOCATABLE :: LS1RB (:)
  
  REAL(KIND=JPRB), POINTER :: ZZ1 (:)
  
  ZZ1 => YLF%P
  
  ALLOCATE (LS1RB (1))
  
  LS1RB (1)%V => ZZ1 
  
  END FUNCTION
  
  FUNCTION LS2RB (YLF, LDACC)
  
  CLASS (FIELD_2RB), POINTER, INTENT (IN) :: YLF
  LOGICAL, OPTIONAL :: LDACC
  
  TYPE (FIELD_1RB_VIEW), ALLOCATABLE :: LS2RB (:)
  
  REAL(KIND=JPRB), POINTER :: ZZ2 (:,:)
  INTEGER(KIND=JPIM) :: I2, I3, J
  
  ZZ2 => YLF%P
  
  ALLOCATE (LS2RB (SIZE (ZZ2, 2)))
  
  J = 1
  
  DO I2 = LBOUND (ZZ2, 2), UBOUND (ZZ2, 2)
    LS2RB (J)%V => ZZ2 (:, I2)
    J = J + 1
  ENDDO
  
  END FUNCTION
  
  FUNCTION LS3RB (YLF, LDACC)
  
  CLASS (FIELD_3RB), POINTER, INTENT (IN) :: YLF
  LOGICAL, OPTIONAL :: LDACC
  
  TYPE (FIELD_1RB_VIEW), ALLOCATABLE :: LS3RB (:)
  
  REAL(KIND=JPRB), POINTER :: ZZ3 (:,:,:)
  INTEGER(KIND=JPIM) :: I2, I3, J
  
  ZZ3 => YLF%P
  
  ALLOCATE (LS3RB (SIZE (ZZ3, 2) * SIZE (ZZ3, 3)))
  
  J = 1
  
  DO I3 = LBOUND (ZZ3, 3), UBOUND (ZZ3, 3)
    DO I2 = LBOUND (ZZ3, 2), UBOUND (ZZ3, 2)
      LS3RB (J)%V => ZZ3 (:, I2, I3)
      J = J + 1
    ENDDO
  ENDDO
  
  END FUNCTION

  FUNCTION LS4RB (YLF, LDACC)
  
    CLASS (FIELD_4RB), POINTER, INTENT (IN) :: YLF
    LOGICAL, OPTIONAL :: LDACC
    
    TYPE (FIELD_1RB_VIEW), ALLOCATABLE :: LS4RB (:)
    
    REAL(KIND=JPRB), POINTER :: ZZ4 (:,:,:,:)
    INTEGER(KIND=JPIM) :: I2, I3, I4,  J
    
    ZZ4 => YLF%P
    
    ALLOCATE (LS4RB (SIZE (ZZ4, 2) * SIZE (ZZ4, 3) * SIZE (ZZ4, 4)))
    
    J = 1
    
    DO I4 = LBOUND (ZZ4, 4), UBOUND (ZZ4, 4)
      DO I3 = LBOUND (ZZ4, 3), UBOUND (ZZ4, 3)
        DO I2 = LBOUND (ZZ4, 2), UBOUND (ZZ4, 2)
          LS4RB (J)%V => ZZ4 (:, I2, I3, I4)
          J = J + 1
        ENDDO
      ENDDO
    ENDDO
    
    END FUNCTION
  
  FUNCTION LS (YLFL, LDACC)
  
  TYPE (FIELD_1RB_VIEW), ALLOCATABLE :: LS (:)
  LOGICAL, OPTIONAL :: LDACC
  
  TYPE (FIELD_BASIC_PTR) :: YLFL (:)
  INTEGER(KIND=JPIM) :: IOFF, ILEN, JFLD, JPASS
  INTEGER(KIND=JPIM) :: ILBOUNDS (5), IUBOUNDS (5)
  
  DO JPASS = 1, 2
  
    IOFF = 0
    
    DO JFLD = 1, SIZE (YLFL)
    
      SELECT TYPE (YLF => YLFL (JFLD)%PTR)
        CLASS IS (FIELD_1RB)
          ILEN = 1
          IF (JPASS == 2) LS (IOFF+1:IOFF+ILEN) = LS1RB (YLF, LDACC)
        CLASS IS (FIELD_2RB)
          CALL YLF%GET_DIMS (LBOUNDS=ILBOUNDS, UBOUNDS=IUBOUNDS)
          ILEN = (IUBOUNDS (2) - ILBOUNDS (2) + 1)
          IF (JPASS == 2) LS (IOFF+1:IOFF+ILEN) = LS2RB (YLF, LDACC)
        CLASS IS (FIELD_3RB)
          CALL YLF%GET_DIMS (LBOUNDS=ILBOUNDS, UBOUNDS=IUBOUNDS)
          ILEN = (IUBOUNDS (3) - ILBOUNDS (3) + 1)
          IF (JPASS == 2) LS (IOFF+1:IOFF+ILEN) = LS3RB (YLF, LDACC)
        CLASS DEFAULT
          STOP 1
      END SELECT
  
      IOFF = IOFF + ILEN
    
    ENDDO
  
    IF (JPASS == 1) THEN
      ALLOCATE (LS (IOFF))
    ENDIF
  
  ENDDO
  
  END FUNCTION LS
 
  END MODULE
  